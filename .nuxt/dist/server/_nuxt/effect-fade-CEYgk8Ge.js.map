{"version":3,"file":"effect-fade-CEYgk8Ge.js","sources":["../../../../node_modules/swiper/modules/controller/controller.js","../../../../node_modules/swiper/shared/effect-init.js","../../../../node_modules/swiper/shared/effect-target.js","../../../../node_modules/swiper/shared/effect-virtual-transition-end.js","../../../../node_modules/swiper/modules/effect-fade/effect-fade.js"],"sourcesContent":["/* eslint no-bitwise: [\"error\", { \"allow\": [\">>\"] }] */\nimport { nextTick } from '../../shared/utils.js';\nexport default function Controller({\n  swiper,\n  extendParams,\n  on\n}) {\n  extendParams({\n    controller: {\n      control: undefined,\n      inverse: false,\n      by: 'slide' // or 'container'\n\n    }\n  });\n  swiper.controller = {\n    control: undefined\n  };\n\n  function LinearSpline(x, y) {\n    const binarySearch = function search() {\n      let maxIndex;\n      let minIndex;\n      let guess;\n      return (array, val) => {\n        minIndex = -1;\n        maxIndex = array.length;\n\n        while (maxIndex - minIndex > 1) {\n          guess = maxIndex + minIndex >> 1;\n\n          if (array[guess] <= val) {\n            minIndex = guess;\n          } else {\n            maxIndex = guess;\n          }\n        }\n\n        return maxIndex;\n      };\n    }();\n\n    this.x = x;\n    this.y = y;\n    this.lastIndex = x.length - 1; // Given an x value (x2), return the expected y2 value:\n    // (x1,y1) is the known point before given value,\n    // (x3,y3) is the known point after given value.\n\n    let i1;\n    let i3;\n\n    this.interpolate = function interpolate(x2) {\n      if (!x2) return 0; // Get the indexes of x1 and x3 (the array indexes before and after given x2):\n\n      i3 = binarySearch(this.x, x2);\n      i1 = i3 - 1; // We have our indexes i1 & i3, so we can calculate already:\n      // y2 := ((x2−x1) × (y3−y1)) ÷ (x3−x1) + y1\n\n      return (x2 - this.x[i1]) * (this.y[i3] - this.y[i1]) / (this.x[i3] - this.x[i1]) + this.y[i1];\n    };\n\n    return this;\n  } // xxx: for now i will just save one spline function to to\n\n\n  function getInterpolateFunction(c) {\n    if (!swiper.controller.spline) {\n      swiper.controller.spline = swiper.params.loop ? new LinearSpline(swiper.slidesGrid, c.slidesGrid) : new LinearSpline(swiper.snapGrid, c.snapGrid);\n    }\n  }\n\n  function setTranslate(_t, byController) {\n    const controlled = swiper.controller.control;\n    let multiplier;\n    let controlledTranslate;\n    const Swiper = swiper.constructor;\n\n    function setControlledTranslate(c) {\n      // this will create an Interpolate function based on the snapGrids\n      // x is the Grid of the scrolled scroller and y will be the controlled scroller\n      // it makes sense to create this only once and recall it for the interpolation\n      // the function does a lot of value caching for performance\n      const translate = swiper.rtlTranslate ? -swiper.translate : swiper.translate;\n\n      if (swiper.params.controller.by === 'slide') {\n        getInterpolateFunction(c); // i am not sure why the values have to be multiplicated this way, tried to invert the snapGrid\n        // but it did not work out\n\n        controlledTranslate = -swiper.controller.spline.interpolate(-translate);\n      }\n\n      if (!controlledTranslate || swiper.params.controller.by === 'container') {\n        multiplier = (c.maxTranslate() - c.minTranslate()) / (swiper.maxTranslate() - swiper.minTranslate());\n        controlledTranslate = (translate - swiper.minTranslate()) * multiplier + c.minTranslate();\n      }\n\n      if (swiper.params.controller.inverse) {\n        controlledTranslate = c.maxTranslate() - controlledTranslate;\n      }\n\n      c.updateProgress(controlledTranslate);\n      c.setTranslate(controlledTranslate, swiper);\n      c.updateActiveIndex();\n      c.updateSlidesClasses();\n    }\n\n    if (Array.isArray(controlled)) {\n      for (let i = 0; i < controlled.length; i += 1) {\n        if (controlled[i] !== byController && controlled[i] instanceof Swiper) {\n          setControlledTranslate(controlled[i]);\n        }\n      }\n    } else if (controlled instanceof Swiper && byController !== controlled) {\n      setControlledTranslate(controlled);\n    }\n  }\n\n  function setTransition(duration, byController) {\n    const Swiper = swiper.constructor;\n    const controlled = swiper.controller.control;\n    let i;\n\n    function setControlledTransition(c) {\n      c.setTransition(duration, swiper);\n\n      if (duration !== 0) {\n        c.transitionStart();\n\n        if (c.params.autoHeight) {\n          nextTick(() => {\n            c.updateAutoHeight();\n          });\n        }\n\n        c.$wrapperEl.transitionEnd(() => {\n          if (!controlled) return;\n\n          if (c.params.loop && swiper.params.controller.by === 'slide') {\n            c.loopFix();\n          }\n\n          c.transitionEnd();\n        });\n      }\n    }\n\n    if (Array.isArray(controlled)) {\n      for (i = 0; i < controlled.length; i += 1) {\n        if (controlled[i] !== byController && controlled[i] instanceof Swiper) {\n          setControlledTransition(controlled[i]);\n        }\n      }\n    } else if (controlled instanceof Swiper && byController !== controlled) {\n      setControlledTransition(controlled);\n    }\n  }\n\n  function removeSpline() {\n    if (!swiper.controller.control) return;\n\n    if (swiper.controller.spline) {\n      swiper.controller.spline = undefined;\n      delete swiper.controller.spline;\n    }\n  }\n\n  on('beforeInit', () => {\n    swiper.controller.control = swiper.params.controller.control;\n  });\n  on('update', () => {\n    removeSpline();\n  });\n  on('resize', () => {\n    removeSpline();\n  });\n  on('observerUpdate', () => {\n    removeSpline();\n  });\n  on('setTranslate', (_s, translate, byController) => {\n    if (!swiper.controller.control) return;\n    swiper.controller.setTranslate(translate, byController);\n  });\n  on('setTransition', (_s, duration, byController) => {\n    if (!swiper.controller.control) return;\n    swiper.controller.setTransition(duration, byController);\n  });\n  Object.assign(swiper.controller, {\n    setTranslate,\n    setTransition\n  });\n}","export default function effectInit(params) {\n  const {\n    effect,\n    swiper,\n    on,\n    setTranslate,\n    setTransition,\n    overwriteParams,\n    perspective,\n    recreateShadows,\n    getEffectParams\n  } = params;\n  on('beforeInit', () => {\n    if (swiper.params.effect !== effect) return;\n    swiper.classNames.push(`${swiper.params.containerModifierClass}${effect}`);\n\n    if (perspective && perspective()) {\n      swiper.classNames.push(`${swiper.params.containerModifierClass}3d`);\n    }\n\n    const overwriteParamsResult = overwriteParams ? overwriteParams() : {};\n    Object.assign(swiper.params, overwriteParamsResult);\n    Object.assign(swiper.originalParams, overwriteParamsResult);\n  });\n  on('setTranslate', () => {\n    if (swiper.params.effect !== effect) return;\n    setTranslate();\n  });\n  on('setTransition', (_s, duration) => {\n    if (swiper.params.effect !== effect) return;\n    setTransition(duration);\n  });\n  on('transitionEnd', () => {\n    if (swiper.params.effect !== effect) return;\n\n    if (recreateShadows) {\n      if (!getEffectParams || !getEffectParams().slideShadows) return; // remove shadows\n\n      swiper.slides.each(slideEl => {\n        const $slideEl = swiper.$(slideEl);\n        $slideEl.find('.swiper-slide-shadow-top, .swiper-slide-shadow-right, .swiper-slide-shadow-bottom, .swiper-slide-shadow-left').remove();\n      }); // create new one\n\n      recreateShadows();\n    }\n  });\n  let requireUpdateOnVirtual;\n  on('virtualUpdate', () => {\n    if (swiper.params.effect !== effect) return;\n\n    if (!swiper.slides.length) {\n      requireUpdateOnVirtual = true;\n    }\n\n    requestAnimationFrame(() => {\n      if (requireUpdateOnVirtual && swiper.slides && swiper.slides.length) {\n        setTranslate();\n        requireUpdateOnVirtual = false;\n      }\n    });\n  });\n}","export default function effectTarget(effectParams, $slideEl) {\n  if (effectParams.transformEl) {\n    return $slideEl.find(effectParams.transformEl).css({\n      'backface-visibility': 'hidden',\n      '-webkit-backface-visibility': 'hidden'\n    });\n  }\n\n  return $slideEl;\n}","export default function effectVirtualTransitionEnd({\n  swiper,\n  duration,\n  transformEl,\n  allSlides\n}) {\n  const {\n    slides,\n    activeIndex,\n    $wrapperEl\n  } = swiper;\n\n  if (swiper.params.virtualTranslate && duration !== 0) {\n    let eventTriggered = false;\n    let $transitionEndTarget;\n\n    if (allSlides) {\n      $transitionEndTarget = transformEl ? slides.find(transformEl) : slides;\n    } else {\n      $transitionEndTarget = transformEl ? slides.eq(activeIndex).find(transformEl) : slides.eq(activeIndex);\n    }\n\n    $transitionEndTarget.transitionEnd(() => {\n      if (eventTriggered) return;\n      if (!swiper || swiper.destroyed) return;\n      eventTriggered = true;\n      swiper.animating = false;\n      const triggerEvents = ['webkitTransitionEnd', 'transitionend'];\n\n      for (let i = 0; i < triggerEvents.length; i += 1) {\n        $wrapperEl.trigger(triggerEvents[i]);\n      }\n    });\n  }\n}","import effectInit from '../../shared/effect-init.js';\nimport effectTarget from '../../shared/effect-target.js';\nimport effectVirtualTransitionEnd from '../../shared/effect-virtual-transition-end.js';\nexport default function EffectFade({\n  swiper,\n  extendParams,\n  on\n}) {\n  extendParams({\n    fadeEffect: {\n      crossFade: false,\n      transformEl: null\n    }\n  });\n\n  const setTranslate = () => {\n    const {\n      slides\n    } = swiper;\n    const params = swiper.params.fadeEffect;\n\n    for (let i = 0; i < slides.length; i += 1) {\n      const $slideEl = swiper.slides.eq(i);\n      const offset = $slideEl[0].swiperSlideOffset;\n      let tx = -offset;\n      if (!swiper.params.virtualTranslate) tx -= swiper.translate;\n      let ty = 0;\n\n      if (!swiper.isHorizontal()) {\n        ty = tx;\n        tx = 0;\n      }\n\n      const slideOpacity = swiper.params.fadeEffect.crossFade ? Math.max(1 - Math.abs($slideEl[0].progress), 0) : 1 + Math.min(Math.max($slideEl[0].progress, -1), 0);\n      const $targetEl = effectTarget(params, $slideEl);\n      $targetEl.css({\n        opacity: slideOpacity\n      }).transform(`translate3d(${tx}px, ${ty}px, 0px)`);\n    }\n  };\n\n  const setTransition = duration => {\n    const {\n      transformEl\n    } = swiper.params.fadeEffect;\n    const $transitionElements = transformEl ? swiper.slides.find(transformEl) : swiper.slides;\n    $transitionElements.transition(duration);\n    effectVirtualTransitionEnd({\n      swiper,\n      duration,\n      transformEl,\n      allSlides: true\n    });\n  };\n\n  effectInit({\n    effect: 'fade',\n    swiper,\n    on,\n    setTranslate,\n    setTransition,\n    overwriteParams: () => ({\n      slidesPerView: 1,\n      slidesPerGroup: 1,\n      watchSlidesProgress: true,\n      spaceBetween: 0,\n      virtualTranslate: !swiper.params.cssMode\n    })\n  });\n}"],"names":[],"mappings":";AAEe,SAAS,WAAW;AAAA,EACjC;AAAA,EACA;AAAA,EACA;AACF,GAAG;AACD,eAAa;AAAA,IACX,YAAY;AAAA,MACV,SAAS;AAAA,MACT,SAAS;AAAA,MACT,IAAI;AAAA;AAAA,IAEL;AAAA,EACL,CAAG;AACD,SAAO,aAAa;AAAA,IAClB,SAAS;AAAA,EACb;AAEE,WAAS,aAAa,GAAG,GAAG;AAC1B,UAAM,eAAe,yBAAS,SAAS;AACrC,UAAI;AACJ,UAAI;AACJ,UAAI;AACJ,aAAO,CAAC,OAAO,QAAQ;AACrB,mBAAW;AACX,mBAAW,MAAM;AAEjB,eAAO,WAAW,WAAW,GAAG;AAC9B,kBAAQ,WAAW,YAAY;AAE/B,cAAI,MAAM,KAAK,KAAK,KAAK;AACvB,uBAAW;AAAA,UACvB,OAAiB;AACL,uBAAW;AAAA,UACZ;AAAA,QACF;AAED,eAAO;AAAA,MACf;AAAA,IACA;AAEI,SAAK,IAAI;AACT,SAAK,IAAI;AACT,SAAK,YAAY,EAAE,SAAS;AAI5B,QAAI;AACJ,QAAI;AAEJ,SAAK,cAAc,SAAS,YAAY,IAAI;AAC1C,UAAI,CAAC;AAAI,eAAO;AAEhB,WAAK,aAAa,KAAK,GAAG,EAAE;AAC5B,WAAK,KAAK;AAGV,cAAQ,KAAK,KAAK,EAAE,EAAE,MAAM,KAAK,EAAE,EAAE,IAAI,KAAK,EAAE,EAAE,MAAM,KAAK,EAAE,EAAE,IAAI,KAAK,EAAE,EAAE,KAAK,KAAK,EAAE,EAAE;AAAA,IAClG;AAEI,WAAO;AAAA,EACR;AAGD,WAAS,uBAAuB,GAAG;AACjC,QAAI,CAAC,OAAO,WAAW,QAAQ;AAC7B,aAAO,WAAW,SAAS,OAAO,OAAO,OAAO,IAAI,aAAa,OAAO,YAAY,EAAE,UAAU,IAAI,IAAI,aAAa,OAAO,UAAU,EAAE,QAAQ;AAAA,IACjJ;AAAA,EACF;AAED,WAAS,aAAa,IAAI,cAAc;AACtC,UAAM,aAAa,OAAO,WAAW;AACrC,QAAI;AACJ,QAAI;AACJ,UAAM,SAAS,OAAO;AAEtB,aAAS,uBAAuB,GAAG;AAKjC,YAAM,YAAY,OAAO,eAAe,CAAC,OAAO,YAAY,OAAO;AAEnE,UAAI,OAAO,OAAO,WAAW,OAAO,SAAS;AAC3C,+BAAuB,CAAC;AAGxB,8BAAsB,CAAC,OAAO,WAAW,OAAO,YAAY,CAAC,SAAS;AAAA,MACvE;AAED,UAAI,CAAC,uBAAuB,OAAO,OAAO,WAAW,OAAO,aAAa;AACvE,sBAAc,EAAE,aAAY,IAAK,EAAE,mBAAmB,OAAO,aAAc,IAAG,OAAO,aAAc;AACnG,+BAAuB,YAAY,OAAO,aAAc,KAAI,aAAa,EAAE;MAC5E;AAED,UAAI,OAAO,OAAO,WAAW,SAAS;AACpC,8BAAsB,EAAE,aAAc,IAAG;AAAA,MAC1C;AAED,QAAE,eAAe,mBAAmB;AACpC,QAAE,aAAa,qBAAqB,MAAM;AAC1C,QAAE,kBAAiB;AACnB,QAAE,oBAAmB;AAAA,IACtB;AAED,QAAI,MAAM,QAAQ,UAAU,GAAG;AAC7B,eAAS,IAAI,GAAG,IAAI,WAAW,QAAQ,KAAK,GAAG;AAC7C,YAAI,WAAW,CAAC,MAAM,gBAAgB,WAAW,CAAC,aAAa,QAAQ;AACrE,iCAAuB,WAAW,CAAC,CAAC;AAAA,QACrC;AAAA,MACF;AAAA,IACF,WAAU,sBAAsB,UAAU,iBAAiB,YAAY;AACtE,6BAAuB,UAAU;AAAA,IAClC;AAAA,EACF;AAED,WAAS,cAAc,UAAU,cAAc;AAC7C,UAAM,SAAS,OAAO;AACtB,UAAM,aAAa,OAAO,WAAW;AACrC,QAAI;AAEJ,aAAS,wBAAwB,GAAG;AAClC,QAAE,cAAc,UAAU,MAAM;AAEhC,UAAI,aAAa,GAAG;AAClB,UAAE,gBAAe;AAEjB,YAAI,EAAE,OAAO,YAAY;AACvB,mBAAS,MAAM;AACb,cAAE,iBAAgB;AAAA,UAC9B,CAAW;AAAA,QACF;AAED,UAAE,WAAW,cAAc,MAAM;AAC/B,cAAI,CAAC;AAAY;AAEjB,cAAI,EAAE,OAAO,QAAQ,OAAO,OAAO,WAAW,OAAO,SAAS;AAC5D,cAAE,QAAO;AAAA,UACV;AAED,YAAE,cAAa;AAAA,QACzB,CAAS;AAAA,MACF;AAAA,IACF;AAED,QAAI,MAAM,QAAQ,UAAU,GAAG;AAC7B,WAAK,IAAI,GAAG,IAAI,WAAW,QAAQ,KAAK,GAAG;AACzC,YAAI,WAAW,CAAC,MAAM,gBAAgB,WAAW,CAAC,aAAa,QAAQ;AACrE,kCAAwB,WAAW,CAAC,CAAC;AAAA,QACtC;AAAA,MACF;AAAA,IACF,WAAU,sBAAsB,UAAU,iBAAiB,YAAY;AACtE,8BAAwB,UAAU;AAAA,IACnC;AAAA,EACF;AAED,WAAS,eAAe;AACtB,QAAI,CAAC,OAAO,WAAW;AAAS;AAEhC,QAAI,OAAO,WAAW,QAAQ;AAC5B,aAAO,WAAW,SAAS;AAC3B,aAAO,OAAO,WAAW;AAAA,IAC1B;AAAA,EACF;AAED,KAAG,cAAc,MAAM;AACrB,WAAO,WAAW,UAAU,OAAO,OAAO,WAAW;AAAA,EACzD,CAAG;AACD,KAAG,UAAU,MAAM;AACjB;EACJ,CAAG;AACD,KAAG,UAAU,MAAM;AACjB;EACJ,CAAG;AACD,KAAG,kBAAkB,MAAM;AACzB;EACJ,CAAG;AACD,KAAG,gBAAgB,CAAC,IAAI,WAAW,iBAAiB;AAClD,QAAI,CAAC,OAAO,WAAW;AAAS;AAChC,WAAO,WAAW,aAAa,WAAW,YAAY;AAAA,EAC1D,CAAG;AACD,KAAG,iBAAiB,CAAC,IAAI,UAAU,iBAAiB;AAClD,QAAI,CAAC,OAAO,WAAW;AAAS;AAChC,WAAO,WAAW,cAAc,UAAU,YAAY;AAAA,EAC1D,CAAG;AACD,SAAO,OAAO,OAAO,YAAY;AAAA,IAC/B;AAAA,IACA;AAAA,EACJ,CAAG;AACH;AC9Le,SAAS,WAAW,QAAQ;AACzC,QAAM;AAAA,IACJ;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACD,IAAG;AACJ,KAAG,cAAc,MAAM;AACrB,QAAI,OAAO,OAAO,WAAW;AAAQ;AACrC,WAAO,WAAW,KAAK,GAAG,OAAO,OAAO,sBAAsB,GAAG,MAAM,EAAE;AAEzE,QAAI,eAAe,eAAe;AAChC,aAAO,WAAW,KAAK,GAAG,OAAO,OAAO,sBAAsB,IAAI;AAAA,IACnE;AAED,UAAM,wBAAwB,kBAAkB,gBAAe,IAAK,CAAA;AACpE,WAAO,OAAO,OAAO,QAAQ,qBAAqB;AAClD,WAAO,OAAO,OAAO,gBAAgB,qBAAqB;AAAA,EAC9D,CAAG;AACD,KAAG,gBAAgB,MAAM;AACvB,QAAI,OAAO,OAAO,WAAW;AAAQ;AACrC;EACJ,CAAG;AACD,KAAG,iBAAiB,CAAC,IAAI,aAAa;AACpC,QAAI,OAAO,OAAO,WAAW;AAAQ;AACrC,kBAAc,QAAQ;AAAA,EAC1B,CAAG;AACD,KAAG,iBAAiB,MAAM;AACxB,QAAI,OAAO,OAAO,WAAW;AAAQ;AAErC,QAAI,iBAAiB;AACnB,UAAI,CAAC,mBAAmB,CAAC,gBAAiB,EAAC;AAAc;AAEzD,aAAO,OAAO,KAAK,aAAW;AAC5B,cAAM,WAAW,OAAO,EAAE,OAAO;AACjC,iBAAS,KAAK,8GAA8G,EAAE,OAAM;AAAA,MAC5I,CAAO;AAED;IACD;AAAA,EACL,CAAG;AACD,MAAI;AACJ,KAAG,iBAAiB,MAAM;AACxB,QAAI,OAAO,OAAO,WAAW;AAAQ;AAErC,QAAI,CAAC,OAAO,OAAO,QAAQ;AACzB,+BAAyB;AAAA,IAC1B;AAED,0BAAsB,MAAM;AAC1B,UAAI,0BAA0B,OAAO,UAAU,OAAO,OAAO,QAAQ;AACnE;AACA,iCAAyB;AAAA,MAC1B;AAAA,IACP,CAAK;AAAA,EACL,CAAG;AACH;AC7De,SAAS,aAAa,cAAc,UAAU;AAC3D,MAAI,aAAa,aAAa;AAC5B,WAAO,SAAS,KAAK,aAAa,WAAW,EAAE,IAAI;AAAA,MACjD,uBAAuB;AAAA,MACvB,+BAA+B;AAAA,IACrC,CAAK;AAAA,EACF;AAED,SAAO;AACT;ACTe,SAAS,2BAA2B;AAAA,EACjD;AAAA,EACA;AAAA,EACA;AAAA,EACA;AACF,GAAG;AACD,QAAM;AAAA,IACJ;AAAA,IACA;AAAA,IACA;AAAA,EACD,IAAG;AAEJ,MAAI,OAAO,OAAO,oBAAoB,aAAa,GAAG;AACpD,QAAI,iBAAiB;AACrB,QAAI;AAEJ,QAAI,WAAW;AACb,6BAAuB,cAAc,OAAO,KAAK,WAAW,IAAI;AAAA,IACtE,OAAW;AACL,6BAAuB,cAAc,OAAO,GAAG,WAAW,EAAE,KAAK,WAAW,IAAI,OAAO,GAAG,WAAW;AAAA,IACtG;AAED,yBAAqB,cAAc,MAAM;AACvC,UAAI;AAAgB;AACpB,UAAI,CAAC,UAAU,OAAO;AAAW;AACjC,uBAAiB;AACjB,aAAO,YAAY;AACnB,YAAM,gBAAgB,CAAC,uBAAuB,eAAe;AAE7D,eAAS,IAAI,GAAG,IAAI,cAAc,QAAQ,KAAK,GAAG;AAChD,mBAAW,QAAQ,cAAc,CAAC,CAAC;AAAA,MACpC;AAAA,IACP,CAAK;AAAA,EACF;AACH;AC/Be,SAAS,WAAW;AAAA,EACjC;AAAA,EACA;AAAA,EACA;AACF,GAAG;AACD,eAAa;AAAA,IACX,YAAY;AAAA,MACV,WAAW;AAAA,MACX,aAAa;AAAA,IACd;AAAA,EACL,CAAG;AAED,QAAM,eAAe,MAAM;AACzB,UAAM;AAAA,MACJ;AAAA,IACD,IAAG;AACJ,UAAM,SAAS,OAAO,OAAO;AAE7B,aAAS,IAAI,GAAG,IAAI,OAAO,QAAQ,KAAK,GAAG;AACzC,YAAM,WAAW,OAAO,OAAO,GAAG,CAAC;AACnC,YAAM,SAAS,SAAS,CAAC,EAAE;AAC3B,UAAI,KAAK,CAAC;AACV,UAAI,CAAC,OAAO,OAAO;AAAkB,cAAM,OAAO;AAClD,UAAI,KAAK;AAET,UAAI,CAAC,OAAO,gBAAgB;AAC1B,aAAK;AACL,aAAK;AAAA,MACN;AAED,YAAM,eAAe,OAAO,OAAO,WAAW,YAAY,KAAK,IAAI,IAAI,KAAK,IAAI,SAAS,CAAC,EAAE,QAAQ,GAAG,CAAC,IAAI,IAAI,KAAK,IAAI,KAAK,IAAI,SAAS,CAAC,EAAE,UAAU,EAAE,GAAG,CAAC;AAC9J,YAAM,YAAY,aAAa,QAAQ,QAAQ;AAC/C,gBAAU,IAAI;AAAA,QACZ,SAAS;AAAA,MACjB,CAAO,EAAE,UAAU,eAAe,EAAE,OAAO,EAAE,UAAU;AAAA,IAClD;AAAA,EACL;AAEE,QAAM,gBAAgB,cAAY;AAChC,UAAM;AAAA,MACJ;AAAA,IACN,IAAQ,OAAO,OAAO;AAClB,UAAM,sBAAsB,cAAc,OAAO,OAAO,KAAK,WAAW,IAAI,OAAO;AACnF,wBAAoB,WAAW,QAAQ;AACvC,+BAA2B;AAAA,MACzB;AAAA,MACA;AAAA,MACA;AAAA,MACA,WAAW;AAAA,IACjB,CAAK;AAAA,EACL;AAEE,aAAW;AAAA,IACT,QAAQ;AAAA,IACR;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA,iBAAiB,OAAO;AAAA,MACtB,eAAe;AAAA,MACf,gBAAgB;AAAA,MAChB,qBAAqB;AAAA,MACrB,cAAc;AAAA,MACd,kBAAkB,CAAC,OAAO,OAAO;AAAA,IACvC;AAAA,EACA,CAAG;AACH;","x_google_ignoreList":[0,1,2,3,4]}