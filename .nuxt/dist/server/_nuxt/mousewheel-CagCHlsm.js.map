{"version":3,"file":"mousewheel-CagCHlsm.js","sources":["../../../../node_modules/swiper/modules/mousewheel/mousewheel.js"],"sourcesContent":["/* eslint-disable consistent-return */\nimport { getWindow } from 'ssr-window';\nimport $ from '../../shared/dom.js';\nimport { now, nextTick } from '../../shared/utils.js';\nexport default function Mousewheel({\n  swiper,\n  extendParams,\n  on,\n  emit\n}) {\n  const window = getWindow();\n  extendParams({\n    mousewheel: {\n      enabled: false,\n      releaseOnEdges: false,\n      invert: false,\n      forceToAxis: false,\n      sensitivity: 1,\n      eventsTarget: 'container',\n      thresholdDelta: null,\n      thresholdTime: null\n    }\n  });\n  swiper.mousewheel = {\n    enabled: false\n  };\n  let timeout;\n  let lastScrollTime = now();\n  let lastEventBeforeSnap;\n  const recentWheelEvents = [];\n\n  function normalize(e) {\n    // Reasonable defaults\n    const PIXEL_STEP = 10;\n    const LINE_HEIGHT = 40;\n    const PAGE_HEIGHT = 800;\n    let sX = 0;\n    let sY = 0; // spinX, spinY\n\n    let pX = 0;\n    let pY = 0; // pixelX, pixelY\n    // Legacy\n\n    if ('detail' in e) {\n      sY = e.detail;\n    }\n\n    if ('wheelDelta' in e) {\n      sY = -e.wheelDelta / 120;\n    }\n\n    if ('wheelDeltaY' in e) {\n      sY = -e.wheelDeltaY / 120;\n    }\n\n    if ('wheelDeltaX' in e) {\n      sX = -e.wheelDeltaX / 120;\n    } // side scrolling on FF with DOMMouseScroll\n\n\n    if ('axis' in e && e.axis === e.HORIZONTAL_AXIS) {\n      sX = sY;\n      sY = 0;\n    }\n\n    pX = sX * PIXEL_STEP;\n    pY = sY * PIXEL_STEP;\n\n    if ('deltaY' in e) {\n      pY = e.deltaY;\n    }\n\n    if ('deltaX' in e) {\n      pX = e.deltaX;\n    }\n\n    if (e.shiftKey && !pX) {\n      // if user scrolls with shift he wants horizontal scroll\n      pX = pY;\n      pY = 0;\n    }\n\n    if ((pX || pY) && e.deltaMode) {\n      if (e.deltaMode === 1) {\n        // delta in LINE units\n        pX *= LINE_HEIGHT;\n        pY *= LINE_HEIGHT;\n      } else {\n        // delta in PAGE units\n        pX *= PAGE_HEIGHT;\n        pY *= PAGE_HEIGHT;\n      }\n    } // Fall-back if spin cannot be determined\n\n\n    if (pX && !sX) {\n      sX = pX < 1 ? -1 : 1;\n    }\n\n    if (pY && !sY) {\n      sY = pY < 1 ? -1 : 1;\n    }\n\n    return {\n      spinX: sX,\n      spinY: sY,\n      pixelX: pX,\n      pixelY: pY\n    };\n  }\n\n  function handleMouseEnter() {\n    if (!swiper.enabled) return;\n    swiper.mouseEntered = true;\n  }\n\n  function handleMouseLeave() {\n    if (!swiper.enabled) return;\n    swiper.mouseEntered = false;\n  }\n\n  function animateSlider(newEvent) {\n    if (swiper.params.mousewheel.thresholdDelta && newEvent.delta < swiper.params.mousewheel.thresholdDelta) {\n      // Prevent if delta of wheel scroll delta is below configured threshold\n      return false;\n    }\n\n    if (swiper.params.mousewheel.thresholdTime && now() - lastScrollTime < swiper.params.mousewheel.thresholdTime) {\n      // Prevent if time between scrolls is below configured threshold\n      return false;\n    } // If the movement is NOT big enough and\n    // if the last time the user scrolled was too close to the current one (avoid continuously triggering the slider):\n    //   Don't go any further (avoid insignificant scroll movement).\n\n\n    if (newEvent.delta >= 6 && now() - lastScrollTime < 60) {\n      // Return false as a default\n      return true;\n    } // If user is scrolling towards the end:\n    //   If the slider hasn't hit the latest slide or\n    //   if the slider is a loop and\n    //   if the slider isn't moving right now:\n    //     Go to next slide and\n    //     emit a scroll event.\n    // Else (the user is scrolling towards the beginning) and\n    // if the slider hasn't hit the first slide or\n    // if the slider is a loop and\n    // if the slider isn't moving right now:\n    //   Go to prev slide and\n    //   emit a scroll event.\n\n\n    if (newEvent.direction < 0) {\n      if ((!swiper.isEnd || swiper.params.loop) && !swiper.animating) {\n        swiper.slideNext();\n        emit('scroll', newEvent.raw);\n      }\n    } else if ((!swiper.isBeginning || swiper.params.loop) && !swiper.animating) {\n      swiper.slidePrev();\n      emit('scroll', newEvent.raw);\n    } // If you got here is because an animation has been triggered so store the current time\n\n\n    lastScrollTime = new window.Date().getTime(); // Return false as a default\n\n    return false;\n  }\n\n  function releaseScroll(newEvent) {\n    const params = swiper.params.mousewheel;\n\n    if (newEvent.direction < 0) {\n      if (swiper.isEnd && !swiper.params.loop && params.releaseOnEdges) {\n        // Return true to animate scroll on edges\n        return true;\n      }\n    } else if (swiper.isBeginning && !swiper.params.loop && params.releaseOnEdges) {\n      // Return true to animate scroll on edges\n      return true;\n    }\n\n    return false;\n  }\n\n  function handle(event) {\n    let e = event;\n    let disableParentSwiper = true;\n    if (!swiper.enabled) return;\n    const params = swiper.params.mousewheel;\n\n    if (swiper.params.cssMode) {\n      e.preventDefault();\n    }\n\n    let target = swiper.$el;\n\n    if (swiper.params.mousewheel.eventsTarget !== 'container') {\n      target = $(swiper.params.mousewheel.eventsTarget);\n    }\n\n    if (!swiper.mouseEntered && !target[0].contains(e.target) && !params.releaseOnEdges) return true;\n    if (e.originalEvent) e = e.originalEvent; // jquery fix\n\n    let delta = 0;\n    const rtlFactor = swiper.rtlTranslate ? -1 : 1;\n    const data = normalize(e);\n\n    if (params.forceToAxis) {\n      if (swiper.isHorizontal()) {\n        if (Math.abs(data.pixelX) > Math.abs(data.pixelY)) delta = -data.pixelX * rtlFactor;else return true;\n      } else if (Math.abs(data.pixelY) > Math.abs(data.pixelX)) delta = -data.pixelY;else return true;\n    } else {\n      delta = Math.abs(data.pixelX) > Math.abs(data.pixelY) ? -data.pixelX * rtlFactor : -data.pixelY;\n    }\n\n    if (delta === 0) return true;\n    if (params.invert) delta = -delta; // Get the scroll positions\n\n    let positions = swiper.getTranslate() + delta * params.sensitivity;\n    if (positions >= swiper.minTranslate()) positions = swiper.minTranslate();\n    if (positions <= swiper.maxTranslate()) positions = swiper.maxTranslate(); // When loop is true:\n    //     the disableParentSwiper will be true.\n    // When loop is false:\n    //     if the scroll positions is not on edge,\n    //     then the disableParentSwiper will be true.\n    //     if the scroll on edge positions,\n    //     then the disableParentSwiper will be false.\n\n    disableParentSwiper = swiper.params.loop ? true : !(positions === swiper.minTranslate() || positions === swiper.maxTranslate());\n    if (disableParentSwiper && swiper.params.nested) e.stopPropagation();\n\n    if (!swiper.params.freeMode || !swiper.params.freeMode.enabled) {\n      // Register the new event in a variable which stores the relevant data\n      const newEvent = {\n        time: now(),\n        delta: Math.abs(delta),\n        direction: Math.sign(delta),\n        raw: event\n      }; // Keep the most recent events\n\n      if (recentWheelEvents.length >= 2) {\n        recentWheelEvents.shift(); // only store the last N events\n      }\n\n      const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;\n      recentWheelEvents.push(newEvent); // If there is at least one previous recorded event:\n      //   If direction has changed or\n      //   if the scroll is quicker than the previous one:\n      //     Animate the slider.\n      // Else (this is the first time the wheel is moved):\n      //     Animate the slider.\n\n      if (prevEvent) {\n        if (newEvent.direction !== prevEvent.direction || newEvent.delta > prevEvent.delta || newEvent.time > prevEvent.time + 150) {\n          animateSlider(newEvent);\n        }\n      } else {\n        animateSlider(newEvent);\n      } // If it's time to release the scroll:\n      //   Return now so you don't hit the preventDefault.\n\n\n      if (releaseScroll(newEvent)) {\n        return true;\n      }\n    } else {\n      // Freemode or scrollContainer:\n      // If we recently snapped after a momentum scroll, then ignore wheel events\n      // to give time for the deceleration to finish. Stop ignoring after 500 msecs\n      // or if it's a new scroll (larger delta or inverse sign as last event before\n      // an end-of-momentum snap).\n      const newEvent = {\n        time: now(),\n        delta: Math.abs(delta),\n        direction: Math.sign(delta)\n      };\n      const ignoreWheelEvents = lastEventBeforeSnap && newEvent.time < lastEventBeforeSnap.time + 500 && newEvent.delta <= lastEventBeforeSnap.delta && newEvent.direction === lastEventBeforeSnap.direction;\n\n      if (!ignoreWheelEvents) {\n        lastEventBeforeSnap = undefined;\n\n        if (swiper.params.loop) {\n          swiper.loopFix();\n        }\n\n        let position = swiper.getTranslate() + delta * params.sensitivity;\n        const wasBeginning = swiper.isBeginning;\n        const wasEnd = swiper.isEnd;\n        if (position >= swiper.minTranslate()) position = swiper.minTranslate();\n        if (position <= swiper.maxTranslate()) position = swiper.maxTranslate();\n        swiper.setTransition(0);\n        swiper.setTranslate(position);\n        swiper.updateProgress();\n        swiper.updateActiveIndex();\n        swiper.updateSlidesClasses();\n\n        if (!wasBeginning && swiper.isBeginning || !wasEnd && swiper.isEnd) {\n          swiper.updateSlidesClasses();\n        }\n\n        if (swiper.params.freeMode.sticky) {\n          // When wheel scrolling starts with sticky (aka snap) enabled, then detect\n          // the end of a momentum scroll by storing recent (N=15?) wheel events.\n          // 1. do all N events have decreasing or same (absolute value) delta?\n          // 2. did all N events arrive in the last M (M=500?) msecs?\n          // 3. does the earliest event have an (absolute value) delta that's\n          //    at least P (P=1?) larger than the most recent event's delta?\n          // 4. does the latest event have a delta that's smaller than Q (Q=6?) pixels?\n          // If 1-4 are \"yes\" then we're near the end of a momentum scroll deceleration.\n          // Snap immediately and ignore remaining wheel events in this scroll.\n          // See comment above for \"remaining wheel events in this scroll\" determination.\n          // If 1-4 aren't satisfied, then wait to snap until 500ms after the last event.\n          clearTimeout(timeout);\n          timeout = undefined;\n\n          if (recentWheelEvents.length >= 15) {\n            recentWheelEvents.shift(); // only store the last N events\n          }\n\n          const prevEvent = recentWheelEvents.length ? recentWheelEvents[recentWheelEvents.length - 1] : undefined;\n          const firstEvent = recentWheelEvents[0];\n          recentWheelEvents.push(newEvent);\n\n          if (prevEvent && (newEvent.delta > prevEvent.delta || newEvent.direction !== prevEvent.direction)) {\n            // Increasing or reverse-sign delta means the user started scrolling again. Clear the wheel event log.\n            recentWheelEvents.splice(0);\n          } else if (recentWheelEvents.length >= 15 && newEvent.time - firstEvent.time < 500 && firstEvent.delta - newEvent.delta >= 1 && newEvent.delta <= 6) {\n            // We're at the end of the deceleration of a momentum scroll, so there's no need\n            // to wait for more events. Snap ASAP on the next tick.\n            // Also, because there's some remaining momentum we'll bias the snap in the\n            // direction of the ongoing scroll because it's better UX for the scroll to snap\n            // in the same direction as the scroll instead of reversing to snap.  Therefore,\n            // if it's already scrolled more than 20% in the current direction, keep going.\n            const snapToThreshold = delta > 0 ? 0.8 : 0.2;\n            lastEventBeforeSnap = newEvent;\n            recentWheelEvents.splice(0);\n            timeout = nextTick(() => {\n              swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);\n            }, 0); // no delay; move on next tick\n          }\n\n          if (!timeout) {\n            // if we get here, then we haven't detected the end of a momentum scroll, so\n            // we'll consider a scroll \"complete\" when there haven't been any wheel events\n            // for 500ms.\n            timeout = nextTick(() => {\n              const snapToThreshold = 0.5;\n              lastEventBeforeSnap = newEvent;\n              recentWheelEvents.splice(0);\n              swiper.slideToClosest(swiper.params.speed, true, undefined, snapToThreshold);\n            }, 500);\n          }\n        } // Emit event\n\n\n        if (!ignoreWheelEvents) emit('scroll', e); // Stop autoplay\n\n        if (swiper.params.autoplay && swiper.params.autoplayDisableOnInteraction) swiper.autoplay.stop(); // Return page scroll on edge positions\n\n        if (position === swiper.minTranslate() || position === swiper.maxTranslate()) return true;\n      }\n    }\n\n    if (e.preventDefault) e.preventDefault();else e.returnValue = false;\n    return false;\n  }\n\n  function events(method) {\n    let target = swiper.$el;\n\n    if (swiper.params.mousewheel.eventsTarget !== 'container') {\n      target = $(swiper.params.mousewheel.eventsTarget);\n    }\n\n    target[method]('mouseenter', handleMouseEnter);\n    target[method]('mouseleave', handleMouseLeave);\n    target[method]('wheel', handle);\n  }\n\n  function enable() {\n    if (swiper.params.cssMode) {\n      swiper.wrapperEl.removeEventListener('wheel', handle);\n      return true;\n    }\n\n    if (swiper.mousewheel.enabled) return false;\n    events('on');\n    swiper.mousewheel.enabled = true;\n    return true;\n  }\n\n  function disable() {\n    if (swiper.params.cssMode) {\n      swiper.wrapperEl.addEventListener(event, handle);\n      return true;\n    }\n\n    if (!swiper.mousewheel.enabled) return false;\n    events('off');\n    swiper.mousewheel.enabled = false;\n    return true;\n  }\n\n  on('init', () => {\n    if (!swiper.params.mousewheel.enabled && swiper.params.cssMode) {\n      disable();\n    }\n\n    if (swiper.params.mousewheel.enabled) enable();\n  });\n  on('destroy', () => {\n    if (swiper.params.cssMode) {\n      enable();\n    }\n\n    if (swiper.mousewheel.enabled) disable();\n  });\n  Object.assign(swiper.mousewheel, {\n    enable,\n    disable\n  });\n}"],"names":["event"],"mappings":"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","x_google_ignoreList":[0]}